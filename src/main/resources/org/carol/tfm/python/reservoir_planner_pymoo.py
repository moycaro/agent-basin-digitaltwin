# -*- coding: utf-8 -*-
"""reservoir_planner_pymoo

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a3n6obVaXJLP-hBDzpIIDb4xXT3-azoY

# Optimización básica para cuenca piloto

Cuatro cuencas: dos de cabecera, una intermedia y una final

**C1**: Cuenca de cabecera
*   Pluviómetro: *SPE00156270*
*   Embalse *E065: Baserca* VOL máximo: 21.793Hm³

**C2**: Cuenca de cabecera
*   Pluviómetro: *SPE0015801*
*   Embalse *E063: Cavallers* VOL máximo: 16.046Hm³

**C3**: Cuenca intermedia
*   Pluviómetro: *SPE0015153*
*   Embalse *E050: Escales* VOL máximo: 152.317Hm³
*   Aforo: *A137*; Umbrales[ Info:120 ]

**C4**: Cuenca de cierre
*   Aforo: *A115*; Umbrales[ Info:130, PreAlarma: 210 ]

### Imports básicos
"""
from pymoo.core.problem import ElementwiseProblem
from pymoo.optimize import minimize
from pymoo.algorithms.moo.nsga2 import NSGA2
from pymoo.operators.mutation.pm import PolynomialMutation
from pymoo.operators.crossover.sbx import SBX
from pymoo.operators.sampling.rnd import FloatRandomSampling

"""### Optimización cuenca piloto"""

from pymoo.core.problem import ElementwiseProblem
from pymoo.optimize import minimize
from pymoo.algorithms.soo.nonconvex.ga import GA
import numpy as np

class CuencaPilotoProblem(ElementwiseProblem):

    def __init__(self, inflow1, inflow2, inflow3
                 , current_storage1, current_storage2, current_storage3
                 , max_capacity1, max_capacity2, max_capacity3
                 , threshold3, threshold4):
        self.inflow1 = inflow1
        self.inflow2 = inflow2
        self.inflow3 = inflow3
        self.current_storage1 = current_storage1
        self.current_storage2 = current_storage2
        self.current_storage3 = current_storage3
        self.max_capacity1 = max_capacity1
        self.max_capacity2 = max_capacity2
        self.max_capacity3 = max_capacity3
        self.threshold3 = threshold3
        self.threshold4 = threshold4

        # Define lower and upper bounds for the storage variables
        xl = np.array([0, 0, 0])  # Minimum storage is 0
        xu = np.array([max_capacity1, max_capacity2,  max_capacity3])  # Maximum storage is up to capacity

        super().__init__(n_var=3, n_obj=3, n_constr=11, xl=xl, xu=xu)

    def _evaluate(self, x, out, *args, **kwargs):
        storage_goal1 = x[0]
        storage_goal2 = x[1]
        storage_goal3 = x[2]

        # C1
        storage1 = np.clip(self.current_storage1 + self.inflow1 - storage_goal1, 0, self.max_capacity1)
        released_water1 = self.inflow1 + self.current_storage1 - storage_goal1

        # C2
        storage2 = np.clip(self.current_storage2 + self.inflow2 - storage_goal2, 0, self.max_capacity2)
        released_water2 = self.inflow2 + self.current_storage2 - storage_goal2

        # C3
        inflow3_adjusted = self.inflow3 + released_water1 + released_water2
        storage3 = np.clip(self.current_storage3 + inflow3_adjusted - storage_goal3, 0, self.max_capacity3)
        released_water3 = inflow3_adjusted + self.current_storage3 - storage_goal3
        excess_release3 = max(0, released_water3 - self.threshold3)

        # C4
        inflow4_adjusted = released_water3
        released_water4 = inflow4_adjusted
        excess_release4 = max(0, released_water4 - self.threshold4)

        # La función objetivo es doble:
        # 1. Maximizar el agua almacenada en ambos embalses (convertido a minimización)
        # 2. Minimizar el exceso de agua liberada sobre los umbrales controlados en aforos

        f_storage = storage1 + storage2 + storage3  # Maximizar agua embalsada
        f_a137 = abs( self.threshold3 - excess_release3)
        f_a115 = abs( self.threshold4 - excess_release4)
        out["F"] = np.column_stack([f_storage, f_a137, f_a115]) # Stack objectives as columns

        # Restricciones
        g1 = -storage1  # El agua almacenada en el embalse E065 no puede ser negativa
        g2 = storage1 - self.max_capacity1  # El agua almacenada en el embalse E065 no puede superar la capacidad máxima

        g3 = -storage2  # El agua almacenada en el embalse E063 no puede ser negativa
        g4 = storage2 - self.max_capacity2  # El agua almacenada en el embalse E063 no puede superar la capacidad máxima

        g5 = -storage3  # El agua almacenada en el embalse E050 no puede ser negativa
        g6 = storage3 - self.max_capacity3  # El agua almacenada en el embalse E050 no puede superar la capacidad máxima

        g7 = storage_goal1 - ( self.current_storage1 + self.inflow1 ) # No podemos quedarnos con mas agua del que tenemos
        g8 = storage_goal2 - ( self.current_storage2 + self.inflow2 ) # No podemos quedarnos con mas agua del que tenemos
        g9 = storage_goal3 - ( self.current_storage3 + inflow3_adjusted ) # No podemos quedarnos con mas agua del que tenemos

        g10 = -excess_release3  # El agua que pasa por A137 no puede ser negativa
        g11 = -excess_release4  # El agua que pasa por A15 no puede ser negativa

        out["G"] = np.array([g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11])

# Ejemplo de datos
#C1
inflow1 = 60              # Agua entrante en el ciclo actual en el pluvio SPE00156270
current_storage1 = 20     # Estado actual del embalse E065
max_capacity1 = 50        # Capacidad máxima del embalse E065

#C2
inflow2 = 10              # Agua entrante en el ciclo actual en el pluvio SPE00156801
current_storage2 = 20     # Estado actual del embalse E063
max_capacity2 = 50        # Capacidad máxima del embalse E063


#C3
inflow3 = 20               # Agua entrante en el ciclo actual en el pluvio SPE00156153
current_storage3 = 10     # Estado actual del embalse 2
max_capacity3 = 30        # Capacidad máxima del embalse 2
threshold3 = 8            # Umbral de seguridad para el caudal de agua en el agoro A137

#C4
threshold4 = 18            # Umbral de seguridad para el caudal de agua en el agoro A115


problem = CuencaPilotoProblem(
    inflow1=inflow1,
    inflow2=inflow2,
    inflow3=inflow3,
    current_storage1=current_storage1,
    current_storage2=current_storage2,
    current_storage3=current_storage3,
    max_capacity1=max_capacity1,
    max_capacity2=max_capacity2,
    max_capacity3=max_capacity3,
    threshold3=threshold3,
    threshold4=threshold4
)

algorithm = NSGA2(pop_size=20)


res = minimize(problem,
               algorithm,
               termination=('n_gen', 50),
               seed=1,
               verbose=False)

print("\nX-solution <==> %s" % (res.X))
print("\nF-solution <==> %s" % (res.F))
print("\nG-solution <==> %s" % (res.G))